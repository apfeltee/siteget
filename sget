#!/usr/bin/ruby

require "uri"
require "digest"
require "fileutils"
require "base64"
require "nokogiri"
require "httpclient"
require "trollop"

class SiteGet
  @@selectors =
  [
    # javascript
    {sel: "script[src]", rep: "src", ext: "js", post: nil}, #JSPostProcessor
    # images
    {sel: "img", rep: "src", ext: nil},
    {sel: "img[data-thumb]", rep: "data-thumb", ext: nil, post: nil},
    {sel: "input[src][type=image]", rep: "src", ext: nil, post: nil},
    # css
    {sel: "link[rel=stylesheet][href]", rep: "href", ext: "css", post: nil}, # CSSPostProcessor
    # favicons
    {sel: "link[rel=icon][href]", rep: "href", ext: nil, post: nil},
  ]

  def initialize(url, opts)
    @opts = opts
    @site = geturl(url)
    @parsed = URI.parse(url)
    parse
  end

  def mlog(str)
    $stderr << "-- " << str << "\n"
  end

  def geturl(url, **kwargs)
    mlog "downloading #{url.inspect} ..."
    http = HTTPClient.new
    return http.get(url, :follow_redirect => true, **kwargs)
  end

  def guess_ext(base, selector)
    # select (or, rather, guess) extension from the basename of the url
    # this function unfortunately results in a redundant filename, i.e.,
    # "foobar.jpg" gets bastardized into "foobar-jpg.jpg" due to shitty regex
    if selector[:ext] == nil then
      if (ext = File.extname(base)) != nil && (ext.length > 0) then
        # discard leading dot, i.e., ".jpg" => "jpg"
        return ext[1 .. -1]
      end
      return "unknown"
    end
    return selector[:ext]
  end

  def mkurl(oldurl, selector)
    url = oldurl
    if oldurl.match(/^(https?|ftp)/) or (autoscm = oldurl.match(/^\/\//)) then
      if autoscm then
        # in case of "//somehost.com/..." urls, just create an absolute url by
        # reusing the scheme from the mothership
        url = @parsed.scheme + ":" + oldurl
      end
    else
      # otherwise, macgyver the url together from the mothership scheme and host
      url = String.new
      url << @parsed.scheme << "://" << @parsed.host
      # if the url starts with a slash, it's an absolute path (i.e., "/blah/something.js")
      if oldurl.match(/^\//) then
        url << oldurl
      else
        # otherwise, it's a relative one (i.e., "subdir/whatever/thing.js")
        url << File.dirname(@parsed.path) << "/" << oldurl
      end
    end
    # get url components (for query string)
    purl = URI.parse(url)
    #basename = File.basename(purl.path)
    basename = purl.path
    # make a "clean" name...
    # well, not really clean, but better than using a sha256 hash
    cleanname = (basename + (purl.query ? purl.query : "")).gsub(/[^0-9A-Za-z]/, "-").gsub(/^-/, "")
    # create a physical location for the file to be written to
    fulldest = File.join(@opts[:resdir], cleanname + "." + guess_ext(basename, selector))
    # coincidentally, the local url is the same as the file dest. whudathunkit
    if File.file?(fulldest) then
      return fulldest
    end
    response = geturl(url)
    if response then
      FileUtils.mkdir_p(@opts[:resdir])
      File.open(fulldest, "wb") do |fh|
        fh << response.body
      end
      return fulldest
    end
    raise Exception, "bad response from geturl?"
  end

  def parse
    body = @site.body
    main = Nokogiri::HTML(body)
    @@selectors.each do |selector|
      # iterate over each selector
      mlog "++ processing selector #{selector.inspect} ..."
      if (nodes = main.css(selector[:sel])) then
        nodes.each do |node|
          url = node[selector[:rep]]
          localurl = mkurl(url, selector)
          mlog "rewriting #{url.inspect}"
          # modify the node with the new url
          # gotta love nokogiri
          node[selector[:rep]] = localurl
        end
      end
    end
    # write the shite to file
    File.open(@opts[:htmlfile], "w") do |fh|
      fh << main.to_html
    end
  end
end

opts = Trollop::options do
  opt :destination, "Use <destination> as directory to store website", default: ".", type: :string
  opt :htmlfile, "Use <htmlfile> instead of index.html", default: "index.html", type: :string
  opt :resdir, "Use <resdir> instead of 'res' as resources directory name", default: "res", type: :string
end

argv = ARGV
if argv.length > 0 then
  p argv
  p opts
  SiteGet.new(argv.shift, opts)
end
